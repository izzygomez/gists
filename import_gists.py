"""
import_gists.py

Imports single-file GitHub Gists into a local git repo, preserving commit
history with cleaned-up commit messages.

Requires: git-filter-repo, `brew install git-filter-repo`.

Usage:
    python import_gists.py <gists_to_import.txt>

gists_to_import.txt format:
  - one gist per line: <filename> <gist_id>
  - where <gist_id> is the ID in the gist URL
    https://gist.github.com/<username>/<gist_id>
  - & <filename> is the gist filename & what it will be called in the repo

Example:
    gpg-usage-notes.md db73e0538f2f24ea5836c4a5b9e7d9f2
    precise_race_splits.py 22532b2e0b6a7ce1c481d2dda65c82e6

Must be run from inside the target git repo.
"""

import datetime
import importlib.machinery
import importlib.util
import os
import shutil
import subprocess
import sys
import tempfile
from pathlib import Path


# ANSI color codes, disabled if not a TTY
def _colors():
    if sys.stdout.isatty():
        return {
            "bold": "\033[1m",
            "dim": "\033[2m",
            "red": "\033[31m",
            "green": "\033[32m",
            "yellow": "\033[33m",
            "cyan": "\033[36m",
            "reset": "\033[0m",
        }
    return {
        "bold": "",
        "dim": "",
        "red": "",
        "green": "",
        "yellow": "",
        "cyan": "",
        "reset": "",
    }


C = _colors()


def _load_git_filter_repo():
    """Import git-filter-repo from brew installation."""
    path = shutil.which("git-filter-repo")
    if not path:
        sys.exit(
            f"{C['red']}Error:{C['reset']} git-filter-repo not found. "
            "Run: `brew install git-filter-repo`"
        )
    loader = importlib.machinery.SourceFileLoader("git_filter_repo", path)
    spec = importlib.util.spec_from_loader("git_filter_repo", loader)
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module


git_filter_repo = _load_git_filter_repo()

SCRIPT_NAME = "import_gists.py"
REPO_URL = "https://github.com/izzygomez/gists"


class CommandError(Exception):
    """Raised when a shell command fails."""


def run(cmd, cwd=None):
    """Run a shell command & return output. Raises CommandError on failure."""
    result = subprocess.run(
        cmd,
        shell=True,
        cwd=cwd,
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        raise CommandError(f"Command failed: {cmd}\n{result.stderr}")
    return result


def get_gist_branch(gist_dir):
    """Determine if gist uses 'main' or 'master' branch."""
    result = run("git branch --show-current", cwd=gist_dir)
    return result.stdout.strip()


def make_commit_callback(filename, gist_id):
    """Create a commit message rewriter for the given filename."""

    def rewrite_commit(commit, _metadata):
        parts = commit.author_date.split()
        timestamp = int(parts[0])
        tz = parts[1].decode() if isinstance(parts[1], bytes) else parts[1]
        date_str = datetime.datetime.fromtimestamp(timestamp).strftime(
            "%Y-%m-%d %H:%M:%S"
        )

        msg = (
            f"edited '{filename}' on https://gist.github.com/{gist_id} on {date_str} {tz}\n"
            f"\n"
            f"this commit was auto-generated by `{SCRIPT_NAME}`, "
            f"which can be found at {REPO_URL}\n"
        )
        commit.message = msg.encode()

    return rewrite_commit


def import_gist(filename, gist_id, repo_dir, temp_dir):
    """Import a single gist into the repo.

    Returns None on success, or an error message string on failure.
    """
    print(
        f"\n{C['bold']}{C['cyan']}>>> Importing {filename}{C['reset']} {C['dim']}(from gist.github.com/{gist_id}){C['reset']}"
    )

    gist_dir = temp_dir / f"gist-{gist_id}"

    try:
        ### Clone the gist
        print(f"    {C['yellow']}Cloning gist into temp dir...{C['reset']}")
        clone_cmd = f"git clone git@gist.github.com:{gist_id}.git {gist_dir}"
        print(f"    {C['dim']}{clone_cmd}{C['reset']}")
        run(clone_cmd)

        ### Validate gist contents
        # Get all files in gist (excluding .git directory)
        gist_files = [f.name for f in gist_dir.iterdir() if f.is_file()]
        if len(gist_files) == 0:
            raise CommandError("Gist contains no files")
        if len(gist_files) > 1:
            raise CommandError(
                f"Gist contains multiple files ({', '.join(gist_files)}). "
                "Only single-file gists are supported."
            )
        actual_filename = gist_files[0]
        if actual_filename != filename:
            raise CommandError(
                f"Filename mismatch: expected '{filename}', but gist contains '{actual_filename}'"
            )
        print(f"    {C['dim']}Verified: gist only contains '{filename}'{C['reset']}")

        # Get branch name (master or main)
        branch = get_gist_branch(gist_dir)
        print(f"    {C['dim']}Branch: {branch}{C['reset']}")

        ### Rewrite commit messages using git-filter-repo as a library
        print(
            f"    {C['yellow']}Rewriting commit messages using git-filter-repo...{C['reset']}"
        )
        print(C["dim"], end="")  # dim any output from git-filter-repo
        args = git_filter_repo.FilteringOptions.parse_args(["--force", "--quiet"])
        repo_filter = git_filter_repo.RepoFilter(
            args,
            commit_callback=make_commit_callback(filename, gist_id),
        )
        # filter-repo needs to run from within the repo
        original_dir = Path.cwd()
        try:
            os.chdir(gist_dir)
            repo_filter.run()
        finally:
            os.chdir(original_dir)
        print(C["reset"], end="")  # reset after git-filter-repo output

        ### Merge into main repo
        print(f"    {C['yellow']}Merging into this repo...{C['reset']}")
        print(f"    {C['dim']}Running these commands inside {repo_dir}:{C['reset']}")
        remote_name = f"temp-{gist_id[:8]}"

        add_remote_cmd = f"git remote add {remote_name} {gist_dir}"
        print(f"    {C['dim']}{add_remote_cmd}{C['reset']}")
        run(add_remote_cmd, cwd=repo_dir)

        fetch_cmd = f"git fetch {remote_name}"
        print(f"    {C['dim']}{fetch_cmd}{C['reset']}")
        run(fetch_cmd, cwd=repo_dir)

        merge_cmd = f"git merge {remote_name}/{branch} --allow-unrelated-histories -m \"merge '{filename}' from https://gist.github.com/{gist_id}\""
        print(f"    {C['dim']}{merge_cmd}{C['reset']}")
        run(merge_cmd, cwd=repo_dir)

        remove_remote_cmd = f"git remote remove {remote_name}"
        print(f"    {C['dim']}{remove_remote_cmd}{C['reset']}")
        run(remove_remote_cmd, cwd=repo_dir)

        print(f"    {C['green']}Done with {filename}{C['reset']}")
        return None

    except CommandError as e:
        print(f"    {C['red']}Failed: {e}{C['reset']}")
        return f"{filename} ({gist_id}): {e}"


def main():
    if len(sys.argv) != 2:
        print(f"{C['red']}Usage:{C['reset']} `{SCRIPT_NAME} <input_file>`")
        sys.exit(1)

    input_file = Path(sys.argv[1])
    if not input_file.exists():
        print(f"{C['red']}Error:{C['reset']} Input file not found: {input_file}")
        sys.exit(1)

    repo_dir = Path.cwd()
    if not (repo_dir / ".git").exists():
        print(f"{C['red']}Error:{C['reset']} must be run from inside a git repo")
        sys.exit(1)

    # Create empty initial commit if repo has no commits. This is needed for
    # first merge to work as expected.
    result = subprocess.run(
        "git rev-parse HEAD",
        shell=True,
        cwd=repo_dir,
        capture_output=True,
    )
    if result.returncode != 0:
        print(f"{C['yellow']}Creating empty initial commit...{C['reset']}")
        run('git commit --allow-empty -m "empty initial commit"', cwd=repo_dir)

    # Parse input file
    gists = []
    for line in input_file.read_text().strip().split("\n"):
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        parts = line.split()
        if len(parts) != 2:
            print(f"{C['red']}Error:{C['reset']} Invalid line: {line}")
            sys.exit(1)
        gists.append((parts[0], parts[1]))

    print(f"{C['cyan']}Found {len(gists)} gists to import{C['reset']}")

    # Create temp directory & import each gist
    errors = []
    with tempfile.TemporaryDirectory() as temp_dir:
        temp_path = Path(temp_dir)
        for filename, gist_id in gists:
            error = import_gist(filename, gist_id, repo_dir, temp_path)
            if error:
                errors.append(error)

    # Print summary
    succeeded = len(gists) - len(errors)
    if errors:
        print(
            f"\n{C['bold']}{C['red']}>>> Finished with {len(errors)} error(s):{C['reset']}"
        )
        for error in errors:
            print(f"    {C['red']}- {error}{C['reset']}")
        if succeeded > 0:
            print(
                f"\n>>> {C['green']}Successfully imported {succeeded} gist(s).{C['reset']}"
            )
        sys.exit(1)
    else:
        print(
            f"\n{C['bold']}{C['green']}>>> All done! Imported {len(gists)} gists.{C['reset']}"
        )


if __name__ == "__main__":
    main()
